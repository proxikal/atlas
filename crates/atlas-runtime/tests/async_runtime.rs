// Merged: async_future_tests + async_io_tests + async_primitives_tests
// DO NOT EDIT â€” generated by Infra-03a phase consolidation

use atlas_runtime::api::Runtime;
use atlas_runtime::*;
use atlas_runtime::async_runtime::FutureState;
use atlas_runtime::security::SecurityContext;
use atlas_runtime::span::Span;
use atlas_runtime::stdlib::async_io;
use atlas_runtime::value::Value;
use rstest::*;
use std::fs;
use tempfile::TempDir;


// ===== async_future_tests.rs =====

// Integration tests for Future/Promise type and async foundation
//
// Tests Phase-11a: Async Foundation - Future Type & Runtime
// - Future value type
// - Future state machine
// - Future constructor functions
// - Future combinators (futureAll, futureRace)
// - Runtime integration
// - Error handling


/// Helper to evaluate code with the interpreter
fn eval(code: &str) -> Result<Value, Box<dyn std::error::Error>> {
    let mut runtime = Runtime::new(api::ExecutionMode::Interpreter);
    Ok(runtime.eval(code)?)
}

/// Helper to evaluate code expecting success
fn eval_ok(code: &str) -> Value {
    eval(code).unwrap()
}

/// Helper to evaluate code with VM
fn eval_vm(code: &str) -> Result<Value, Box<dyn std::error::Error>> {
    let mut runtime = Runtime::new(api::ExecutionMode::VM);
    Ok(runtime.eval(code)?)
}

// ============================================================================
// Future Type Tests
// ============================================================================

#[test]
fn test_future_resolve_creates_resolved_future() {
    let result = eval_ok("futureResolve(42)");
    assert_eq!(result.type_name(), "future");

    // Check it's resolved
    let is_resolved = eval_ok("futureIsResolved(futureResolve(42))");
    assert_eq!(is_resolved, Value::Bool(true));
}

#[test]
fn test_future_reject_creates_rejected_future() {
    let result = eval_ok("futureReject(\"error\")");
    assert_eq!(result.type_name(), "future");

    // Check it's rejected
    let is_rejected = eval_ok("futureIsRejected(futureReject(\"error\"))");
    assert_eq!(is_rejected, Value::Bool(true));
}

#[test]
fn test_future_new_creates_pending_future() {
    let result = eval_ok("futureNew()");
    assert_eq!(result.type_name(), "future");

    // Check it's pending
    let is_pending = eval_ok("futureIsPending(futureNew())");
    assert_eq!(is_pending, Value::Bool(true));
}

#[test]
fn test_future_clone_shares_state() {
    let code = r#"
        let f1 = futureResolve(100);
        let f2 = f1;
        futureIsResolved(f2)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_display_format() {
    // Futures should have a display format
    let result = eval_ok("toString(futureResolve(42))");
    match result {
        Value::String(s) => {
            assert!(s.contains("Future"));
        }
        _ => panic!("Expected string"),
    }
}

#[test]
fn test_future_type_name() {
    let result = eval_ok("typeof(futureResolve(42))");
    assert_eq!(result, Value::string("future"));
}

#[test]
fn test_future_in_array() {
    let result = eval_ok("[futureResolve(1), futureResolve(2), futureResolve(3)]");
    match result {
        Value::Array(arr) => {
            assert_eq!(arr.lock().unwrap().len(), 3);
            for val in arr.lock().unwrap().iter() {
                assert_eq!(val.type_name(), "future");
            }
        }
        _ => panic!("Expected array"),
    }
}

#[test]
fn test_future_multiple_references() {
    let code = r#"
        let f = futureResolve(42);
        let arr = [f, f, f];
        len(arr)
    "#;
    assert_eq!(eval_ok(code), Value::Number(3.0));
}

// ============================================================================
// Future State Machine Tests
// ============================================================================

#[test]
fn test_pending_to_resolved_transition() {
    // In phase-11a, futures created with futureNew stay pending
    // This test verifies pending futures remain pending
    let result = eval_ok("futureIsPending(futureNew())");
    assert_eq!(result, Value::Bool(true));
}

#[test]
fn test_resolved_state_is_final() {
    let code = r#"
        let f = futureResolve(42);
        futureIsResolved(f)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_rejected_state_is_final() {
    let code = r#"
        let f = futureReject("error");
        futureIsRejected(f)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_state_check_resolved() {
    let code = r#"
        let f = futureResolve(100);
        [futureIsResolved(f), futureIsRejected(f), futureIsPending(f)]
    "#;
    let result = eval_ok(code);
    match result {
        Value::Array(arr) => {
            let values = arr.lock().unwrap();
            assert_eq!(values[0], Value::Bool(true)); // isResolved
            assert_eq!(values[1], Value::Bool(false)); // isRejected
            assert_eq!(values[2], Value::Bool(false)); // isPending
        }
        _ => panic!("Expected array"),
    }
}

#[test]
fn test_future_state_check_rejected() {
    let code = r#"
        let f = futureReject("fail");
        [futureIsResolved(f), futureIsRejected(f), futureIsPending(f)]
    "#;
    let result = eval_ok(code);
    match result {
        Value::Array(arr) => {
            let values = arr.lock().unwrap();
            assert_eq!(values[0], Value::Bool(false)); // isResolved
            assert_eq!(values[1], Value::Bool(true)); // isRejected
            assert_eq!(values[2], Value::Bool(false)); // isPending
        }
        _ => panic!("Expected array"),
    }
}

// ============================================================================
// Future Combinators Tests
// ============================================================================

#[test]
fn test_future_all_with_all_resolved() {
    let code = r#"
        let futures = [
            futureResolve(1),
            futureResolve(2),
            futureResolve(3)
        ];
        let result = futureAll(futures);
        futureIsResolved(result)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_all_with_one_rejected() {
    let code = r#"
        let futures = [
            futureResolve(1),
            futureReject("error"),
            futureResolve(3)
        ];
        let result = futureAll(futures);
        futureIsRejected(result)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_all_empty_array() {
    let code = r#"
        let result = futureAll([]);
        futureIsResolved(result)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_all_with_pending() {
    let code = r#"
        let futures = [
            futureResolve(1),
            futureNew(),  // pending
            futureResolve(3)
        ];
        let result = futureAll(futures);
        futureIsPending(result)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_race_first_resolved() {
    let code = r#"
        let futures = [
            futureResolve(1),
            futureNew(),  // pending
            futureResolve(3)
        ];
        let result = futureRace(futures);
        futureIsResolved(result)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_race_first_rejected() {
    let code = r#"
        let f1 = futureReject("error");
        let f2 = futureNew();
        let futures = [f1, f2];
        let result = futureRace(futures);
        futureIsRejected(result)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_race_all_pending() {
    let code = r#"
        let futures = [
            futureNew(),
            futureNew()
        ];
        let result = futureRace(futures);
        futureIsPending(result)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

// ============================================================================
// Runtime Integration Tests
// ============================================================================

#[test]
fn test_tokio_runtime_initializes() {
    // Just creating a future should initialize the runtime
    eval_ok("futureResolve(42)");
    // No panic = success
}

#[test]
fn test_multiple_concurrent_futures() {
    let code = r#"
        let f1 = futureResolve(1);
        let f2 = futureResolve(2);
        let f3 = futureResolve(3);
        let f4 = futureResolve(4);
        let f5 = futureResolve(5);
        let futures = [f1, f2, f3, f4, f5];
        let result = futureAll(futures);
        futureIsResolved(result)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

// ============================================================================
// Error Handling Tests
// ============================================================================

#[test]
fn test_future_reject_propagates_error() {
    let code = r#"
        let f = futureReject("something went wrong");
        futureIsRejected(f)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_all_rejects_on_any_error() {
    let code = r#"
        let futures = [
            futureResolve(1),
            futureResolve(2),
            futureReject("error in middle"),
            futureResolve(4)
        ];
        futureIsRejected(futureAll(futures))
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_wrong_type_to_future_is_pending() {
    let result = eval("futureIsPending(42)");
    assert!(result.is_err());
}

#[test]
fn test_future_all_requires_array() {
    let result = eval("futureAll(42)");
    assert!(result.is_err());
}

#[test]
fn test_future_all_requires_array_of_futures() {
    let result = eval("futureAll([1, 2, 3])");
    assert!(result.is_err());
}

// ============================================================================
// Integration & Real-World Patterns Tests
// ============================================================================

#[test]
fn test_future_pattern_conditional_resolution() {
    let code = r#"
        let shouldSucceed = true;
        let future = futureResolve("success");
        futureIsResolved(future)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_pattern_collect_results() {
    let code = r#"
        let f1 = futureResolve(2);
        let f2 = futureResolve(4);
        let f3 = futureResolve(6);
        let futures = [f1, f2, f3];
        futureIsResolved(futureAll(futures))
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_pattern_error_handling() {
    let code = r#"
        let operation = futureReject("network error");
        let isRejected = futureIsRejected(operation);
        isRejected
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_pattern_timeout_simulation() {
    let code = r#"
        // Simulate timeout by racing with immediate rejection
        let operation = futureNew();  // Never completes
        let timeout = futureReject("timeout");
        let result = futureRace([operation, timeout]);
        futureIsRejected(result)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

#[test]
fn test_future_pattern_fallback_chain() {
    let code = r#"
        let primary = futureReject("primary failed");
        let secondary = futureResolve("secondary success");
        let result = futureRace([primary, secondary]);
        // First to complete (primary rejection) wins
        futureIsRejected(result)
    "#;
    assert_eq!(eval_ok(code), Value::Bool(true));
}

// ============================================================================
// VM Parity Tests
// ============================================================================

#[test]
fn test_vm_future_resolve() {
    let code = "futureIsResolved(futureResolve(42))";
    let result = eval_vm(code).unwrap();
    assert_eq!(result, Value::Bool(true));
}

#[test]
fn test_vm_future_reject() {
    let code = "futureIsRejected(futureReject(\"error\"))";
    let result = eval_vm(code).unwrap();
    assert_eq!(result, Value::Bool(true));
}

#[test]
fn test_vm_future_all() {
    let code = r#"
        futureIsResolved(futureAll([futureResolve(1), futureResolve(2)]))
    "#;
    let result = eval_vm(code).unwrap();
    assert_eq!(result, Value::Bool(true));
}

#[test]
fn test_vm_future_race() {
    let code = r#"
        futureIsResolved(futureRace([futureResolve(1), futureNew()]))
    "#;
    let result = eval_vm(code).unwrap();
    assert_eq!(result, Value::Bool(true));
}

// ===== async_io_tests.rs =====

// Async I/O tests
//
// Tests for async file and HTTP operations that return Futures.


// ============================================================================
// Async File Reading Tests (8 tests)
// ============================================================================

#[rstest]
fn test_read_small_file_async() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("test.txt");
    fs::write(&file_path, "Hello, async!").unwrap();

    let security = SecurityContext::allow_all();
    let args = [Value::string(file_path.to_str().unwrap())];
    let result = async_io::read_file_async(&args, Span::dummy(), &security).unwrap();

    // Extract Future
    let future = match result {
        Value::Future(f) => f,
        _ => panic!("Expected Future"),
    };

    // Should be resolved (block_on completes immediately)
    assert!(future.is_resolved());

    match future.get_state() {
        FutureState::Resolved(Value::String(s)) => {
            assert_eq!(&**s, "Hello, async!");
        }
        _ => panic!("Expected resolved string"),
    }
}

#[rstest]
fn test_read_large_file_async() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("large.txt");
    let large_content = "x".repeat(10000);
    fs::write(&file_path, &large_content).unwrap();

    let security = SecurityContext::allow_all();
    let args = [Value::string(file_path.to_str().unwrap())];
    let result = async_io::read_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!("Expected Future"),
    };

    assert!(future.is_resolved());
    match future.get_state() {
        FutureState::Resolved(Value::String(s)) => {
            assert_eq!(s.len(), 10000);
        }
        _ => panic!("Expected resolved string"),
    }
}

#[rstest]
fn test_read_non_existent_file_async() {
    let security = SecurityContext::allow_all();
    let args = [Value::string("/nonexistent/file.txt")];

    // Permission check fails before async operation starts
    let result = async_io::read_file_async(&args, Span::dummy(), &security);
    assert!(result.is_err());
}

#[rstest]
fn test_read_permission_denied_async() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("test.txt");
    fs::write(&file_path, "secret").unwrap();

    let security = SecurityContext::new();
    let args = [Value::string(file_path.to_str().unwrap())];

    // Permission check should fail
    let result = async_io::read_file_async(&args, Span::dummy(), &security);
    assert!(result.is_err());
}

#[rstest]
fn test_multiple_concurrent_reads() {
    let temp_dir = TempDir::new().unwrap();
    let file1 = temp_dir.path().join("file1.txt");
    let file2 = temp_dir.path().join("file2.txt");
    let file3 = temp_dir.path().join("file3.txt");

    fs::write(&file1, "content1").unwrap();
    fs::write(&file2, "content2").unwrap();
    fs::write(&file3, "content3").unwrap();

    let security = SecurityContext::allow_all();

    // Read all three files concurrently
    let args1 = [Value::string(file1.to_str().unwrap())];
    let args2 = [Value::string(file2.to_str().unwrap())];
    let args3 = [Value::string(file3.to_str().unwrap())];

    let result1 = async_io::read_file_async(&args1, Span::dummy(), &security).unwrap();
    let result2 = async_io::read_file_async(&args2, Span::dummy(), &security).unwrap();
    let result3 = async_io::read_file_async(&args3, Span::dummy(), &security).unwrap();

    // All should be resolved
    let f1 = match result1 {
        Value::Future(f) => f,
        _ => panic!(),
    };
    let f2 = match result2 {
        Value::Future(f) => f,
        _ => panic!(),
    };
    let f3 = match result3 {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(f1.is_resolved());
    assert!(f2.is_resolved());
    assert!(f3.is_resolved());
}

#[rstest]
fn test_read_utf8_file_async() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("utf8.txt");
    fs::write(&file_path, "Hello ä¸–ç•Œ ðŸš€").unwrap();

    let security = SecurityContext::allow_all();
    let args = [Value::string(file_path.to_str().unwrap())];
    let result = async_io::read_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    match future.get_state() {
        FutureState::Resolved(Value::String(s)) => {
            assert_eq!(&**s, "Hello ä¸–ç•Œ ðŸš€");
        }
        _ => panic!(),
    }
}

#[rstest]
fn test_read_empty_file_async() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("empty.txt");
    fs::write(&file_path, "").unwrap();

    let security = SecurityContext::allow_all();
    let args = [Value::string(file_path.to_str().unwrap())];
    let result = async_io::read_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    match future.get_state() {
        FutureState::Resolved(Value::String(s)) => {
            assert_eq!(&**s, "");
        }
        _ => panic!(),
    }
}

#[rstest]
fn test_cancel_read_operation() {
    // With current implementation using block_on, cancellation isn't supported
    // This test documents the expected behavior for future async executor
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("test.txt");
    fs::write(&file_path, "data").unwrap();

    let security = SecurityContext::allow_all();
    let args = [Value::string(file_path.to_str().unwrap())];
    let result = async_io::read_file_async(&args, Span::dummy(), &security).unwrap();

    // Future completes immediately with current implementation
    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };
    assert!(future.is_resolved());
}

// ============================================================================
// Async File Writing Tests (8 tests)
// ============================================================================

#[rstest]
fn test_write_small_file_async() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("write.txt");

    let security = SecurityContext::allow_all();
    let args = [
        Value::string(file_path.to_str().unwrap()),
        Value::string("async write"),
    ];
    let result = async_io::write_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());

    // Verify file was written
    let content = fs::read_to_string(&file_path).unwrap();
    assert_eq!(content, "async write");
}

#[rstest]
fn test_write_large_file_async() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("large.txt");
    let large_content = "y".repeat(50000);

    let security = SecurityContext::allow_all();
    let args = [
        Value::string(file_path.to_str().unwrap()),
        Value::string(&large_content),
    ];
    let result = async_io::write_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());

    let content = fs::read_to_string(&file_path).unwrap();
    assert_eq!(content.len(), 50000);
}

#[rstest]
fn test_overwrite_existing_file_async() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("overwrite.txt");
    fs::write(&file_path, "original").unwrap();

    let security = SecurityContext::allow_all();
    let args = [
        Value::string(file_path.to_str().unwrap()),
        Value::string("overwritten"),
    ];
    let result = async_io::write_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());

    let content = fs::read_to_string(&file_path).unwrap();
    assert_eq!(content, "overwritten");
}

#[rstest]
fn test_write_permission_denied_async() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("denied.txt");

    let security = SecurityContext::new();
    let args = [
        Value::string(file_path.to_str().unwrap()),
        Value::string("data"),
    ];

    let result = async_io::write_file_async(&args, Span::dummy(), &security);
    assert!(result.is_err());
}

#[rstest]
fn test_multiple_concurrent_writes() {
    let temp_dir = TempDir::new().unwrap();
    let file1 = temp_dir.path().join("w1.txt");
    let file2 = temp_dir.path().join("w2.txt");
    let file3 = temp_dir.path().join("w3.txt");

    let security = SecurityContext::allow_all();

    let args1 = [
        Value::string(file1.to_str().unwrap()),
        Value::string("data1"),
    ];
    let args2 = [
        Value::string(file2.to_str().unwrap()),
        Value::string("data2"),
    ];
    let args3 = [
        Value::string(file3.to_str().unwrap()),
        Value::string("data3"),
    ];

    let r1 = async_io::write_file_async(&args1, Span::dummy(), &security).unwrap();
    let r2 = async_io::write_file_async(&args2, Span::dummy(), &security).unwrap();
    let r3 = async_io::write_file_async(&args3, Span::dummy(), &security).unwrap();

    // All should complete
    match r1 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }
    match r2 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }
    match r3 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }

    // Verify all files
    assert_eq!(fs::read_to_string(&file1).unwrap(), "data1");
    assert_eq!(fs::read_to_string(&file2).unwrap(), "data2");
    assert_eq!(fs::read_to_string(&file3).unwrap(), "data3");
}

#[rstest]
fn test_write_to_non_existent_directory_creates() {
    let temp_dir = TempDir::new().unwrap();
    let nested_path = temp_dir.path().join("new_dir").join("file.txt");

    let security = SecurityContext::allow_all();
    let args = [
        Value::string(nested_path.to_str().unwrap()),
        Value::string("nested"),
    ];

    let result = async_io::write_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());
    assert_eq!(fs::read_to_string(&nested_path).unwrap(), "nested");
}

#[rstest]
fn test_write_empty_string_async() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("empty.txt");

    let security = SecurityContext::allow_all();
    let args = [
        Value::string(file_path.to_str().unwrap()),
        Value::string(""),
    ];

    let result = async_io::write_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());
    assert_eq!(fs::read_to_string(&file_path).unwrap(), "");
}

#[rstest]
fn test_atomic_write_option() {
    // Current implementation doesn't support atomic writes explicitly
    // This test documents expected behavior
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("atomic.txt");

    let security = SecurityContext::allow_all();
    let args = [
        Value::string(file_path.to_str().unwrap()),
        Value::string("atomic data"),
    ];

    let result = async_io::write_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());
    assert_eq!(fs::read_to_string(&file_path).unwrap(), "atomic data");
}

// ============================================================================
// Async File Appending Tests (5 tests)
// ============================================================================

#[rstest]
fn test_append_to_existing_file() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("append.txt");
    fs::write(&file_path, "initial\n").unwrap();

    let security = SecurityContext::allow_all();
    let args = [
        Value::string(file_path.to_str().unwrap()),
        Value::string("appended\n"),
    ];

    let result = async_io::append_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());
    assert_eq!(
        fs::read_to_string(&file_path).unwrap(),
        "initial\nappended\n"
    );
}

#[rstest]
fn test_append_creates_new_file() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("new_append.txt");

    let security = SecurityContext::allow_all();
    let args = [
        Value::string(file_path.to_str().unwrap()),
        Value::string("first line\n"),
    ];

    let result = async_io::append_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());
    assert_eq!(fs::read_to_string(&file_path).unwrap(), "first line\n");
}

#[rstest]
fn test_multiple_concurrent_appends() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("concurrent_append.txt");
    fs::write(&file_path, "start\n").unwrap();

    let security = SecurityContext::allow_all();

    // Multiple appends to same file
    let args1 = [
        Value::string(file_path.to_str().unwrap()),
        Value::string("line1\n"),
    ];
    let args2 = [
        Value::string(file_path.to_str().unwrap()),
        Value::string("line2\n"),
    ];

    let r1 = async_io::append_file_async(&args1, Span::dummy(), &security).unwrap();
    let r2 = async_io::append_file_async(&args2, Span::dummy(), &security).unwrap();

    match r1 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }
    match r2 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }

    let content = fs::read_to_string(&file_path).unwrap();
    assert!(content.contains("start"));
    assert!(content.contains("line1"));
    assert!(content.contains("line2"));
}

#[rstest]
fn test_append_permission_denied() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("denied_append.txt");

    let security = SecurityContext::new();
    let args = [
        Value::string(file_path.to_str().unwrap()),
        Value::string("data"),
    ];

    let result = async_io::append_file_async(&args, Span::dummy(), &security);
    assert!(result.is_err());
}

#[rstest]
fn test_append_empty_string() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("append_empty.txt");
    fs::write(&file_path, "content").unwrap();

    let security = SecurityContext::allow_all();
    let args = [
        Value::string(file_path.to_str().unwrap()),
        Value::string(""),
    ];

    let result = async_io::append_file_async(&args, Span::dummy(), &security).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());
    assert_eq!(fs::read_to_string(&file_path).unwrap(), "content");
}

// ============================================================================
// Async HTTP Operations Tests (10 tests)
// ============================================================================

#[rstest]
#[ignore] // Requires network - run with --ignored
fn test_get_request_async() {
    let args = [Value::string("https://httpbin.org/get")];

    let result = async_io::http_get_async(&args, Span::dummy()).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());

    match future.get_state() {
        FutureState::Resolved(Value::HttpResponse(resp)) => {
            assert!(resp.status() >= 200 && resp.status() < 300);
        }
        _ => panic!("Expected resolved HTTP response"),
    }
}

#[rstest]
#[ignore] // Requires network
fn test_post_request_async() {
    let args = [
        Value::string("https://httpbin.org/post"),
        Value::string("test data"),
    ];

    let result = async_io::http_post_async(&args, Span::dummy()).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());

    match future.get_state() {
        FutureState::Resolved(Value::HttpResponse(resp)) => {
            assert_eq!(resp.status(), 200);
        }
        _ => panic!(),
    }
}

#[rstest]
#[ignore] // Requires network
fn test_put_request_async() {
    let args = [
        Value::string("https://httpbin.org/put"),
        Value::string("updated data"),
    ];

    let result = async_io::http_put_async(&args, Span::dummy()).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());
}

#[rstest]
#[ignore] // Requires network
fn test_delete_request_async() {
    let args = [Value::string("https://httpbin.org/delete")];

    let result = async_io::http_delete_async(&args, Span::dummy()).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());
}

#[rstest]
#[ignore] // Requires network
fn test_multiple_concurrent_requests() {
    let args1 = [Value::string("https://httpbin.org/get")];
    let args2 = [Value::string("https://httpbin.org/headers")];
    let args3 = [Value::string("https://httpbin.org/user-agent")];

    let r1 = async_io::http_get_async(&args1, Span::dummy()).unwrap();
    let r2 = async_io::http_get_async(&args2, Span::dummy()).unwrap();
    let r3 = async_io::http_get_async(&args3, Span::dummy()).unwrap();

    // All should complete
    match r1 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }
    match r2 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }
    match r3 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }
}

#[rstest]
#[ignore = "requires network"]
fn test_request_timeout() {
    // Timeout test - use a slow endpoint
    use atlas_runtime::stdlib::http::HttpRequest;
    use std::sync::Arc;

    let request = HttpRequest::new(
        "GET".to_string(),
        "https://httpbin.org/delay/10".to_string(),
    )
    .with_timeout(1); // 1 second timeout

    let args = [Value::HttpRequest(Arc::new(request))];
    let result = async_io::http_send_async(&args, Span::dummy()).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    // Should be resolved with error (timeout)
    match future.get_state() {
        FutureState::Rejected(_) => {
            // Expected timeout
        }
        _ => {
            // May also succeed if connection is very fast
        }
    }
}

#[rstest]
#[ignore = "requires network"]
fn test_network_error_handling() {
    let args = [Value::string(
        "https://this-domain-does-not-exist-12345.com",
    )];

    let result = async_io::http_get_async(&args, Span::dummy()).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    // Should be rejected with connection error
    match future.get_state() {
        FutureState::Rejected(Value::String(msg)) => {
            assert!(msg.contains("error") || msg.contains("Error"));
        }
        _ => panic!("Expected rejected future with error"),
    }
}

#[rstest]
#[ignore] // Requires network
fn test_large_response_handling() {
    let args = [Value::string("https://httpbin.org/bytes/100000")];

    let result = async_io::http_get_async(&args, Span::dummy()).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());

    match future.get_state() {
        FutureState::Resolved(Value::HttpResponse(resp)) => {
            assert!(resp.body().len() >= 100000);
        }
        _ => panic!(),
    }
}

#[rstest]
#[ignore] // Requires network
fn test_concurrent_requests_different_hosts() {
    let args1 = [Value::string("https://httpbin.org/get")];
    let args2 = [Value::string(
        "https://jsonplaceholder.typicode.com/todos/1",
    )];

    let r1 = async_io::http_get_async(&args1, Span::dummy()).unwrap();
    let r2 = async_io::http_get_async(&args2, Span::dummy()).unwrap();

    match r1 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }
    match r2 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }
}

#[rstest]
#[ignore] // Requires network
fn test_request_with_custom_headers_async() {
    use atlas_runtime::stdlib::http::HttpRequest;
    use std::sync::Arc;

    let request = HttpRequest::new("GET".to_string(), "https://httpbin.org/headers".to_string())
        .with_header("X-Custom-Header".to_string(), "test-value".to_string());

    let args = [Value::HttpRequest(Arc::new(request))];
    let result = async_io::http_send_async(&args, Span::dummy()).unwrap();

    let future = match result {
        Value::Future(f) => f,
        _ => panic!(),
    };

    assert!(future.is_resolved());

    match future.get_state() {
        FutureState::Resolved(Value::HttpResponse(resp)) => {
            // Response should contain our custom header in the JSON
            assert!(resp.body().contains("X-Custom-Header"));
        }
        _ => panic!(),
    }
}

// ============================================================================
// Concurrent Operations Tests (8 tests)
// ============================================================================

#[rstest]
fn test_parallel_file_reads_with_future_all() {
    use atlas_runtime::async_runtime::future_all;

    let temp_dir = TempDir::new().unwrap();
    let file1 = temp_dir.path().join("f1.txt");
    let file2 = temp_dir.path().join("f2.txt");
    let file3 = temp_dir.path().join("f3.txt");

    fs::write(&file1, "content1").unwrap();
    fs::write(&file2, "content2").unwrap();
    fs::write(&file3, "content3").unwrap();

    let security = SecurityContext::allow_all();

    let args1 = [Value::string(file1.to_str().unwrap())];
    let args2 = [Value::string(file2.to_str().unwrap())];
    let args3 = [Value::string(file3.to_str().unwrap())];

    let r1 = async_io::read_file_async(&args1, Span::dummy(), &security).unwrap();
    let r2 = async_io::read_file_async(&args2, Span::dummy(), &security).unwrap();
    let r3 = async_io::read_file_async(&args3, Span::dummy(), &security).unwrap();

    let futures = vec![
        match r1 {
            Value::Future(f) => (*f).clone(),
            _ => panic!(),
        },
        match r2 {
            Value::Future(f) => (*f).clone(),
            _ => panic!(),
        },
        match r3 {
            Value::Future(f) => (*f).clone(),
            _ => panic!(),
        },
    ];

    let combined = future_all(futures);
    assert!(combined.is_resolved());

    match combined.get_state() {
        FutureState::Resolved(Value::Array(arr)) => {
            assert_eq!(arr.lock().unwrap().len(), 3);
        }
        _ => panic!("Expected array of results"),
    }
}

#[rstest]
#[ignore] // Requires network
fn test_parallel_http_requests_with_future_all() {
    use atlas_runtime::async_runtime::future_all;

    let args1 = [Value::string("https://httpbin.org/get")];
    let args2 = [Value::string("https://httpbin.org/headers")];

    let r1 = async_io::http_get_async(&args1, Span::dummy()).unwrap();
    let r2 = async_io::http_get_async(&args2, Span::dummy()).unwrap();

    let futures = vec![
        match r1 {
            Value::Future(f) => (*f).clone(),
            _ => panic!(),
        },
        match r2 {
            Value::Future(f) => (*f).clone(),
            _ => panic!(),
        },
    ];

    let combined = future_all(futures);
    assert!(combined.is_resolved());

    match combined.get_state() {
        FutureState::Resolved(Value::Array(arr)) => {
            assert_eq!(arr.lock().unwrap().len(), 2);
        }
        _ => panic!(),
    }
}

#[rstest]
fn test_mixed_file_and_network_operations() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("test.txt");
    fs::write(&file_path, "data").unwrap();

    let security = SecurityContext::allow_all();

    // Mix of file and HTTP operations
    let file_args = [Value::string(file_path.to_str().unwrap())];

    let file_result = async_io::read_file_async(&file_args, Span::dummy(), &security).unwrap();

    // File operation should complete
    match file_result {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }
}

#[rstest]
fn test_future_race_for_first_completed() {
    use atlas_runtime::async_runtime::future_race;

    let temp_dir = TempDir::new().unwrap();
    let file1 = temp_dir.path().join("f1.txt");
    let file2 = temp_dir.path().join("f2.txt");

    fs::write(&file1, "first").unwrap();
    fs::write(&file2, "second").unwrap();

    let security = SecurityContext::allow_all();

    let args1 = [Value::string(file1.to_str().unwrap())];
    let args2 = [Value::string(file2.to_str().unwrap())];

    let r1 = async_io::read_file_async(&args1, Span::dummy(), &security).unwrap();
    let r2 = async_io::read_file_async(&args2, Span::dummy(), &security).unwrap();

    let futures = vec![
        match r1 {
            Value::Future(f) => (*f).clone(),
            _ => panic!(),
        },
        match r2 {
            Value::Future(f) => (*f).clone(),
            _ => panic!(),
        },
    ];

    let winner = future_race(futures);
    assert!(winner.is_resolved());

    // Should be one of the file contents
    match winner.get_state() {
        FutureState::Resolved(Value::String(s)) => {
            assert!(s.as_ref() == "first" || s.as_ref() == "second");
        }
        _ => panic!(),
    }
}

#[rstest]
fn test_error_in_parallel_operations() {
    let temp_dir = TempDir::new().unwrap();
    let file1 = temp_dir.path().join("exists.txt");
    fs::write(&file1, "data").unwrap();

    let security = SecurityContext::allow_all();

    // One successful read
    let args1 = [Value::string(file1.to_str().unwrap())];

    let r1 = async_io::read_file_async(&args1, Span::dummy(), &security).unwrap();
    // Note: Testing error handling in parallel operations requires actual async
    // execution model. This documents expected behavior for future implementations.

    match r1 {
        Value::Future(f) => assert!(f.is_resolved()),
        _ => panic!(),
    }
}

#[rstest]
fn test_many_concurrent_operations() {
    let temp_dir = TempDir::new().unwrap();
    let security = SecurityContext::allow_all();

    let mut futures = Vec::new();

    // Create and read 10 files concurrently
    for i in 0..10 {
        let file_path = temp_dir.path().join(format!("file{}.txt", i));
        fs::write(&file_path, format!("content{}", i)).unwrap();

        let args = [Value::string(file_path.to_str().unwrap())];
        let result = async_io::read_file_async(&args, Span::dummy(), &security).unwrap();

        futures.push(match result {
            Value::Future(f) => (*f).clone(),
            _ => panic!(),
        });
    }

    // All should complete
    for future in futures {
        assert!(future.is_resolved());
    }
}

#[rstest]
fn test_resource_limit_handling() {
    // Current implementation uses block_on, so no resource limits apply
    // This test documents expected behavior for future async executor
    let temp_dir = TempDir::new().unwrap();
    let security = SecurityContext::allow_all();

    // Create many concurrent operations
    let mut count = 0;
    for i in 0..50 {
        let file_path = temp_dir.path().join(format!("r{}.txt", i));
        fs::write(&file_path, "data").unwrap();

        let args = [Value::string(file_path.to_str().unwrap())];
        if let Ok(Value::Future(f)) = async_io::read_file_async(&args, Span::dummy(), &security) {
            if f.is_resolved() {
                count += 1;
            }
        }
    }

    assert_eq!(count, 50);
}

#[rstest]
fn test_ordered_results_from_future_all() {
    use atlas_runtime::async_runtime::future_all;

    let temp_dir = TempDir::new().unwrap();
    let security = SecurityContext::allow_all();

    let mut futures = Vec::new();

    for i in 0..5 {
        let file_path = temp_dir.path().join(format!("ord{}.txt", i));
        fs::write(&file_path, format!("{}", i)).unwrap();

        let args = [Value::string(file_path.to_str().unwrap())];
        let result = async_io::read_file_async(&args, Span::dummy(), &security).unwrap();

        futures.push(match result {
            Value::Future(f) => (*f).clone(),
            _ => panic!(),
        });
    }

    let combined = future_all(futures);
    assert!(combined.is_resolved());

    match combined.get_state() {
        FutureState::Resolved(Value::Array(arr)) => {
            let values = arr.lock().unwrap();
            assert_eq!(values.len(), 5);
            // Results should be in order
            for (i, val) in values.iter().enumerate() {
                match val {
                    Value::String(s) => assert_eq!(&**s, &i.to_string()),
                    _ => panic!(),
                }
            }
        }
        _ => panic!(),
    }
}

// ============================================================================
// Await Helper Tests (2 tests)
// ============================================================================

#[rstest]
fn test_await_resolved_future() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("await_test.txt");
    fs::write(&file_path, "awaited").unwrap();

    let security = SecurityContext::allow_all();
    let args = [Value::string(file_path.to_str().unwrap())];
    let future_result = async_io::read_file_async(&args, Span::dummy(), &security).unwrap();

    // Use await helper
    let await_args = [future_result];
    let result = async_io::await_future(&await_args, Span::dummy()).unwrap();

    match result {
        Value::String(s) => assert_eq!(&**s, "awaited"),
        _ => panic!("Expected string from await"),
    }
}

#[rstest]
#[ignore = "requires network"]
fn test_await_rejected_future() {
    let args = [Value::string("https://this-will-fail.invalid")];
    let future_result = async_io::http_get_async(&args, Span::dummy()).unwrap();

    // Await should return error
    let await_args = [future_result];
    let result = async_io::await_future(&await_args, Span::dummy());

    assert!(result.is_err());
}

// ===== async_primitives_tests.rs =====

// Comprehensive async primitives tests (Phase-11c)
//
// Tests for task spawning, channels, timers, mutex, and timeout operations.
// Tests the async primitives from Atlas code (not direct Rust API calls).


/// Helper to evaluate code with the interpreter
/// Helper to evaluate code expecting success
// ============================================================================
// Task Spawning Tests (10 tests)
// ============================================================================

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_spawn_simple_task() {
    let code = r#"
        let future = futureResolve(42);
        let handle = spawn(future, "simple_task");
        taskStatus(handle)
    "#;
    let result = eval_ok(code);
    // Should return a status string
    assert!(matches!(result, Value::String(_)));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_task_returns_value() {
    let code = r#"
        let future = futureResolve(100);
        let handle = spawn(future, null);
        taskId(handle)
    "#;
    let result = eval_ok(code);
    // Just verify we get a task ID (number)
    assert!(matches!(result, Value::Number(_)));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_multiple_concurrent_tasks() {
    let code = r#"
        let h1 = spawn(async { 1 }, "task1");
        let h2 = spawn(async { 2 }, "task2");
        let h3 = spawn(async { 3 }, "task3");

        // Get task names
        taskName(h1)
    "#;
    let result = eval_ok(code);
    match result {
        Value::String(s) => assert_eq!(&*s, "task1"),
        other => panic!("Expected String, got {:?}", other),
    }
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_task_with_sleep() {
    let code = r#"
        let handle = spawn(async {
            await sleep(50);
            42
        }, null);
        let result = await taskJoin(handle);
        match result {
            Ok(val) => val,
            Err(msg) => -1
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_named_tasks() {
    let code = r#"
        let handle = spawn(async { 1 }, "named_task_123");
        taskName(handle)
    "#;
    let result = eval_ok(code);
    match result {
        Value::String(s) => assert_eq!(&*s, "named_task_123"),
        other => panic!("Expected String, got {:?}", other),
    }
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_task_id_uniqueness() {
    let code = r#"
        let h1 = spawn(async { 1 }, null);
        let h2 = spawn(async { 2 }, null);
        let id1 = taskId(h1);
        let id2 = taskId(h2);
        id1 != id2
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Bool(true));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_spawn_with_string_result() {
    let code = r#"
        let handle = spawn(async { "hello" }, null);
        let result = await taskJoin(handle);
        match result {
            Ok(val) => val,
            Err(msg) => "error"
        }
    "#;
    let result = eval_ok(code);
    match result {
        Value::String(s) => assert_eq!(&*s, "hello"),
        other => panic!("Expected String, got {:?}", other),
    }
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_spawn_with_bool_result() {
    let code = r#"
        let handle = spawn(async { true }, null);
        let result = await taskJoin(handle);
        match result {
            Ok(val) => val,
            Err(msg) => false
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Bool(true));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_spawn_with_array_result() {
    let code = r#"
        let handle = spawn(async { [1, 2, 3] }, null);
        let result = await taskJoin(handle);
        match result {
            Ok(val) => len(val),
            Err(msg) => -1
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(3.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_spawn_multiple_and_join_all() {
    let code = r#"
        let h1 = spawn(async { 10 }, null);
        let h2 = spawn(async { 20 }, null);
        let h3 = spawn(async { 30 }, null);

        let results = await joinAll([h1, h2, h3]);
        len(results)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(3.0));
}

// ============================================================================
// Channel Tests (12 tests)
// ============================================================================

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_create_bounded_channel() {
    let code = r#"
        let channel = channelBounded(10);
        len(channel)
    "#;
    let result = eval_ok(code);
    // Should return array of [sender, receiver]
    assert_eq!(result, Value::Number(2.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_create_unbounded_channel() {
    let code = r#"
        let channel = channelUnbounded();
        len(channel)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(2.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_send_and_receive_message() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        channelSend(sender, 42);
        await channelReceive(receiver)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_multiple_messages_in_order() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        channelSend(sender, 1);
        channelSend(sender, 2);
        channelSend(sender, 3);

        let v1 = await channelReceive(receiver);
        let v2 = await channelReceive(receiver);
        let v3 = await channelReceive(receiver);

        v1 + v2 + v3
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(6.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_bounded_channel_capacity() {
    let code = r#"
        let channel = channelBounded(2);
        let sender = channel[0];

        channelSend(sender, 1);
        channelSend(sender, 2);
        channelSend(sender, 3);

        // Should succeed
        true
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Bool(true));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_channel_with_string_messages() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        channelSend(sender, "hello");
        await channelReceive(receiver)
    "#;
    let result = eval_ok(code);
    match result {
        Value::String(s) => assert_eq!(&*s, "hello"),
        other => panic!("Expected String, got {:?}", other),
    }
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_channel_with_bool_messages() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        channelSend(sender, true);
        await channelReceive(receiver)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Bool(true));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_channel_with_array_messages() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        channelSend(sender, [1, 2]);
        let result = await channelReceive(receiver);
        len(result)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(2.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_channel_multiple_sends_before_receive() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        // Send many messages
        for (var i: number = 0; i < 10; i = i + 1) {
            channelSend(sender, i);
        }

        // Receive first message
        await channelReceive(receiver)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(0.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_channel_interleaved_send_receive() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        var sum: number = 0;
        for (var i: number = 0; i < 5; i = i + 1) {
            channelSend(sender, i);
            let val = await channelReceive(receiver);
            sum = sum + val;
        }

        sum
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(10.0)); // 0+1+2+3+4 = 10
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_channel_with_null_messages() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        channelSend(sender, null);
        await channelReceive(receiver)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Null);
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_channel_send_receive_types() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        channelSend(sender, 42);
        channelSend(sender, "test");
        channelSend(sender, true);

        let v1 = await channelReceive(receiver);
        let v2 = await channelReceive(receiver);
        let v3 = await channelReceive(receiver);

        // All received
        true
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Bool(true));
}

// ============================================================================
// Sleep and Timer Tests (8 tests)
// ============================================================================

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_sleep_for_duration() {
    let code = r#"
        await sleep(10);
        42
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_sleep_zero_duration() {
    let code = r#"
        await sleep(0);
        42
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_sleep_short_duration() {
    let code = r#"
        await sleep(5);
        123
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(123.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_sleep_in_task() {
    let code = r#"
        let handle = spawn(async {
            await sleep(10);
            42
        }, null);
        let result = await taskJoin(handle);
        match result {
            Ok(val) => val,
            Err(msg) => -1
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_sleep_sequence() {
    let code = r#"
        await sleep(5);
        await sleep(5);
        await sleep(5);
        42
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_sleep_with_value_return() {
    let code = r#"
        fn sleepAndReturn(value: number) -> Future<number> {
            return async {
                await sleep(5);
                value
            };
        }

        await sleepAndReturn(123)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(123.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_timer_basic() {
    let code = r#"
        await timer(10);
        42
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_interval_basic() {
    let code = r#"
        let handle = interval(10, async { 42 });
        // Cancel immediately
        cancelTimer(handle);
        true
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Bool(true));
}

// ============================================================================
// Timeout Tests (6 tests)
// ============================================================================

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_timeout_completes_before_limit() {
    let code = r#"
        let result = await timeout(async { 42 }, 100);
        match result {
            Ok(val) => val,
            Err(msg) => -1
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_timeout_immediate_completion() {
    let code = r#"
        let result = await timeout(async { 42 }, 50);
        match result {
            Ok(val) => val,
            Err(msg) => -1
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_timeout_with_task() {
    let code = r#"
        let handle = spawn(async {
            let result = await timeout(async { 42 }, 50);
            match result {
                Ok(val) => val,
                Err(msg) => -1
            }
        }, null);
        let result = await taskJoin(handle);
        match result {
            Ok(val) => val,
            Err(msg) => -2
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_timeout_preserves_value() {
    let code = r#"
        let result = await timeout(async { "test_value" }, 50);
        match result {
            Ok(val) => val,
            Err(msg) => "error"
        }
    "#;
    let result = eval_ok(code);
    match result {
        Value::String(s) => assert_eq!(&*s, "test_value"),
        other => panic!("Expected String, got {:?}", other),
    }
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_timeout_with_sleep() {
    let code = r#"
        let result = await timeout(async {
            await sleep(5);
            42
        }, 50);
        match result {
            Ok(val) => val,
            Err(msg) => -1
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_timeout_returns_result() {
    let code = r#"
        let result = await timeout(async { 100 }, 50);
        // Result should be a Result type
        match result {
            Ok(val) => true,
            Err(msg) => false
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Bool(true));
}

// ============================================================================
// Async Mutex Tests (6 tests)
// ============================================================================

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_create_async_mutex() {
    let code = r#"
        let mutex = asyncMutex(42);
        // Should create successfully
        true
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Bool(true));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_async_mutex_lock_and_get() {
    let code = r#"
        let mutex = asyncMutex(42);
        let guard = await asyncMutexLock(mutex);
        asyncMutexGet(guard)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_async_mutex_update() {
    let code = r#"
        let mutex = asyncMutex(0);
        let guard = await asyncMutexLock(mutex);
        asyncMutexSet(guard, 42);
        asyncMutexGet(guard)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_async_mutex_with_string() {
    let code = r#"
        let mutex = asyncMutex("hello");
        let guard = await asyncMutexLock(mutex);
        asyncMutexGet(guard)
    "#;
    let result = eval_ok(code);
    match result {
        Value::String(s) => assert_eq!(&*s, "hello"),
        other => panic!("Expected String, got {:?}", other),
    }
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_async_mutex_sequential_locks() {
    let code = r#"
        let mutex = asyncMutex(0);

        var guard: AsyncMutexGuard = await asyncMutexLock(mutex);
        asyncMutexSet(guard, 1);
        asyncMutexUnlock(guard);

        guard = await asyncMutexLock(mutex);
        asyncMutexGet(guard)
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(1.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_async_mutex_in_task() {
    let code = r#"
        let mutex = asyncMutex(0);
        let handle = spawn(async {
            let guard = await asyncMutexLock(mutex);
            asyncMutexSet(guard, 42);
            asyncMutexGet(guard)
        }, null);
        let result = await taskJoin(handle);
        match result {
            Ok(val) => val,
            Err(msg) => -1
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

// ============================================================================
// Integration Tests (5 tests)
// ============================================================================

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_task_with_channel_communication() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        let producer = spawn(async {
            channelSend(sender, 10);
            channelSend(sender, 20);
            channelSend(sender, 30);
        }, "producer");

        let consumer = spawn(async {
            let v1 = await channelReceive(receiver);
            let v2 = await channelReceive(receiver);
            let v3 = await channelReceive(receiver);
            v1 + v2 + v3
        }, "consumer");

        let result = await taskJoin(consumer);
        match result {
            Ok(val) => val,
            Err(msg) => -1
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(60.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_timeout_with_channel() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        // Send after a delay
        spawn(async {
            await sleep(5);
            channelSend(sender, 42);
        }, null);

        // Try to receive with timeout
        let result = await timeout(channelReceive(receiver), 50);
        match result {
            Ok(val) => val,
            Err(msg) => -1
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_mutex_shared_between_tasks() {
    let code = r#"
        let mutex = asyncMutex(0);

        let t1 = spawn(async {
            let guard = await asyncMutexLock(mutex);
            let val = asyncMutexGet(guard);
            asyncMutexSet(guard, val + 10);
        }, null);

        let t2 = spawn(async {
            let guard = await asyncMutexLock(mutex);
            let val = asyncMutexGet(guard);
            asyncMutexSet(guard, val + 20);
        }, null);

        await taskJoin(t1);
        await taskJoin(t2);

        let guard = await asyncMutexLock(mutex);
        asyncMutexGet(guard)
    "#;
    let result = eval_ok(code);
    // Should be either 10 or 30 depending on task order
    assert!(matches!(result, Value::Number(n) if n == 10.0 || n == 30.0));
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_complex_async_workflow() {
    let code = r#"
        let channel = channelUnbounded();
        let sender = channel[0];
        let receiver = channel[1];

        // Producer task
        spawn(async {
            for (var i: number = 1; i <= 5; i = i + 1) {
                await sleep(2);
                channelSend(sender, i);
            }
        }, "producer");

        // Consumer task
        var sum: number = 0;
        for (var i: number = 0; i < 5; i = i + 1) {
            let val = await channelReceive(receiver);
            sum = sum + val;
        }

        sum
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(15.0)); // 1+2+3+4+5
}

#[test]
#[ignore = "requires tokio LocalSet context â€” re-enable when async runtime phase completes"]
fn test_retry_with_timeout_pattern() {
    let code = r#"
        fn operation() -> Future<number> {
            return async {
                await sleep(5);
                42
            };
        }

        let result = await retryWithTimeout(operation, 3, 50);
        match result {
            Ok(val) => val,
            Err(msg) => -1
        }
    "#;
    let result = eval_ok(code);
    assert_eq!(result, Value::Number(42.0));
}
