# Virtual Machine Architecture

Stack-based VM with explicit call frames.

## VM Structure

```rust
// vm/ module (vm/mod.rs + vm/frame.rs)
pub struct VM {
    stack: Vec<Value>,
    frames: Vec<CallFrame>,
    globals: HashMap<String, Value>,
    bytecode: Bytecode,
    ip: usize,  // Instruction pointer
}

pub struct CallFrame {
    pub function_name: String,
    pub return_ip: usize,
    pub stack_base: usize,  // Where this frame's locals start
    pub local_count: usize,
}

impl VM {
    pub fn new(bytecode: Bytecode) -> Self {
        Self {
            stack: Vec::with_capacity(256),
            frames: Vec::new(),
            globals: HashMap::new(),
            bytecode,
            ip: 0,
        }
    }

    pub fn run(&mut self) -> Result<Option<Value>, RuntimeError> {
        loop {
            let opcode = self.read_opcode()?;

            match opcode {
                Opcode::Constant => {
                    let index = self.read_u16() as usize;
                    let value = self.bytecode.constants[index].clone();
                    self.push(value);
                }
                Opcode::Null => self.push(Value::Null),
                Opcode::True => self.push(Value::Bool(true)),
                Opcode::False => self.push(Value::Bool(false)),

                Opcode::GetLocal => {
                    let index = self.read_u16() as usize;
                    let base = self.current_frame().stack_base;
                    let value = self.stack[base + index].clone();
                    self.push(value);
                }
                Opcode::SetLocal => {
                    let index = self.read_u16() as usize;
                    let base = self.current_frame().stack_base;
                    let value = self.peek(0).clone();
                    self.stack[base + index] = value;
                }

                Opcode::Add => {
                    let b = self.pop();
                    let a = self.pop();
                    match (&a, &b) {
                        (Value::Number(x), Value::Number(y)) => {
                            let result = x + y;
                            if result.is_nan() || result.is_infinite() {
                                return Err(RuntimeError::InvalidNumericResult);
                            }
                            self.push(Value::Number(result));
                        }
                        (Value::String(x), Value::String(y)) => {
                            self.push(Value::String(Rc::new(format!("{}{}", x, y))));
                        }
                        _ => return Err(RuntimeError::TypeError),
                    }
                }
                Opcode::Sub => self.binary_numeric_op(|a, b| a - b)?,
                Opcode::Mul => self.binary_numeric_op(|a, b| a * b)?,
                Opcode::Div => {
                    let b = self.pop_number()?;
                    let a = self.pop_number()?;
                    if b == 0.0 {
                        return Err(RuntimeError::DivideByZero);
                    }
                    let result = a / b;
                    if result.is_nan() || result.is_infinite() {
                        return Err(RuntimeError::InvalidNumericResult);
                    }
                    self.push(Value::Number(result));
                }
                Opcode::Negate => {
                    let value = self.pop();
                    match value {
                        Value::Number(n) => self.push(Value::Number(-n)),
                        _ => return Err(RuntimeError::TypeError),
                    }
                }

                Opcode::Equal => {
                    let b = self.pop();
                    let a = self.pop();
                    self.push(Value::Bool(a == b));
                }
                Opcode::NotEqual => {
                    let b = self.pop();
                    let a = self.pop();
                    self.push(Value::Bool(a != b));
                }
                Opcode::Less => {
                    let b = self.pop_number()?;
                    let a = self.pop_number()?;
                    self.push(Value::Bool(a < b));
                }

                Opcode::Not => {
                    let value = self.pop();
                    match value {
                        Value::Bool(b) => self.push(Value::Bool(!b)),
                        _ => return Err(RuntimeError::TypeError),
                    }
                }

                Opcode::Jump => {
                    let offset = self.read_i16();
                    self.ip = (self.ip as isize + offset as isize) as usize;
                }
                Opcode::JumpIfFalse => {
                    let offset = self.read_i16();
                    if !self.peek(0).is_truthy() {
                        self.ip = (self.ip as isize + offset as isize) as usize;
                    }
                }
                Opcode::Loop => {
                    let offset = self.read_i16();
                    self.ip = (self.ip as isize - offset as isize) as usize;
                }

                Opcode::Array => {
                    let size = self.read_u16() as usize;
                    let mut elements = Vec::with_capacity(size);
                    for _ in 0..size {
                        elements.push(self.pop());
                    }
                    elements.reverse();
                    self.push(Value::Array(Rc::new(RefCell::new(elements))));
                }

                Opcode::GetIndex => {
                    let index = self.pop_number()?;
                    let array = self.pop();
                    match array {
                        Value::Array(arr) => {
                            if index.fract() != 0.0 {
                                return Err(RuntimeError::InvalidIndex);
                            }
                            let idx = index as usize;
                            let borrowed = arr.borrow();
                            if idx >= borrowed.len() {
                                return Err(RuntimeError::OutOfBounds);
                            }
                            self.push(borrowed[idx].clone());
                        }
                        _ => return Err(RuntimeError::TypeError),
                    }
                }

                Opcode::SetIndex => {
                    let value = self.pop();
                    let index = self.pop_number()?;
                    let array = self.pop();
                    match array {
                        Value::Array(arr) => {
                            if index.fract() != 0.0 {
                                return Err(RuntimeError::InvalidIndex);
                            }
                            let idx = index as usize;
                            let mut borrowed = arr.borrow_mut();
                            if idx >= borrowed.len() {
                                return Err(RuntimeError::OutOfBounds);
                            }
                            borrowed[idx] = value;
                        }
                        _ => return Err(RuntimeError::TypeError),
                    }
                }

                Opcode::Pop => {
                    self.pop();
                }

                Opcode::Halt => break,

                _ => return Err(RuntimeError::UnknownOpcode),
            }
        }

        Ok(if self.stack.is_empty() {
            None
        } else {
            Some(self.pop())
        })
    }

    // Helper methods
    fn push(&mut self, value: Value) {
        self.stack.push(value);
    }

    fn pop(&mut self) -> Value {
        self.stack.pop().expect("Stack underflow")
    }

    fn peek(&self, distance: usize) -> &Value {
        &self.stack[self.stack.len() - 1 - distance]
    }

    fn pop_number(&mut self) -> Result<f64, RuntimeError> {
        match self.pop() {
            Value::Number(n) => Ok(n),
            _ => Err(RuntimeError::TypeError),
        }
    }

    fn binary_numeric_op<F>(&mut self, op: F) -> Result<(), RuntimeError>
    where
        F: FnOnce(f64, f64) -> f64,
    {
        let b = self.pop_number()?;
        let a = self.pop_number()?;
        let result = op(a, b);
        if result.is_nan() || result.is_infinite() {
            return Err(RuntimeError::InvalidNumericResult);
        }
        self.push(Value::Number(result));
        Ok(())
    }

    fn read_opcode(&mut self) -> Result<Opcode, RuntimeError> {
        let byte = self.bytecode.instructions[self.ip];
        self.ip += 1;
        Opcode::try_from(byte).map_err(|_| RuntimeError::UnknownOpcode)
    }

    fn read_u8(&mut self) -> u8 {
        let byte = self.bytecode.instructions[self.ip];
        self.ip += 1;
        byte
    }

    fn read_u16(&mut self) -> u16 {
        let hi = self.bytecode.instructions[self.ip] as u16;
        let lo = self.bytecode.instructions[self.ip + 1] as u16;
        self.ip += 2;
        (hi << 8) | lo
    }

    fn read_i16(&mut self) -> i16 {
        self.read_u16() as i16
    }

    fn current_frame(&self) -> &CallFrame {
        self.frames.last().expect("No call frame")
    }
}
```

## Key Design Decisions

- **Stack-based:** Single value stack for all operations
- **Call frames:** Track function calls separately
- **Explicit IP:** Instruction pointer advances manually
- **Big-endian reads:** Match bytecode encoding
- **Error checking:** Every numeric operation checks for NaN/Infinity
