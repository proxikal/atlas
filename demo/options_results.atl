// Option/Result handling and pattern matching

fn parse_number(text: string) -> Result<number, string> {
    // Validate with regex first to avoid runtime parse errors
    let compiled = unwrap(regexNew("^[-+]?[0-9]+(\\.[0-9]+)?$"));
    if regexIsMatch(compiled, text) {
        return Ok(parseFloat(text));
    }
    return Err("not a number");
}

fn safe_divide(a: number, b: number) -> Result<number, string> {
    if b == 0 { return Err("divide by zero"); }
    return Ok(a / b);
}

export fn demo_options_results() -> string {
    let present: Option<number> = Some(7);
    let absent: Option<number> = None;

    let opt_msg = describe_option_number(present) + " | " + describe_option_number(absent);

    let ok_res: Result<number, string> = safe_divide(10, 2);
    let err_res: Result<number, string> = safe_divide(5, 0);

    // Pattern matching over Result
    let res_msg = describe_result(ok_res) + " | " + describe_result(err_res);

    // Result callbacks
    fn double(n: number) -> number { return n * 2; }
    fn annotate(msg: string) -> string { return "annotated: " + msg; }
    let mapped_ok = result_map(ok_res, double);          // Ok(20)
    let mapped_err = result_map_err(err_res, annotate);  // Err("annotated: divide by zero")

    // Option helpers
    let val_or_default: number = unwrap_or_option(present, 0);
    let none_default: number = unwrap_or_option(absent, 99);

    // Result to Option conversions
    let ok_as_option: Option<number> = result_ok(ok_res);
    let err_as_option: Option<string> = result_err(err_res);

    return "options=" + opt_msg
        + "; results=" + res_msg
        + "; map Ok -> " + describe_result(mapped_ok)
        + "; map Err -> " + describe_result(mapped_err)
        + "; unwrap_or(Some)= " + str(val_or_default)
        + "; unwrap_or(None)= " + str(none_default)
        + "; ok() -> " + describe_option_number(ok_as_option)
        + "; err() -> " + describe_option_string(err_as_option);
}

fn describe_option_number(opt: Option<number>) -> string {
    return match opt {
        Some(value) => "Some(" + str(value) + ")",
        None => "None"
    };
}

fn describe_option_string(opt: Option<string>) -> string {
    return match opt {
        Some(value) => "Some(" + value + ")",
        None => "None"
    };
}

fn describe_result(res: Result<number, string>) -> string {
    return match res {
        Ok(value) => "Ok(" + str(value) + ")",
        Err(err) => "Err(" + err + ")"
    };
}
