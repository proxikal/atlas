// HashMap, HashSet, Queue, and Stack collections

export fn demo_collections() -> string {
    // HashMap
    let map = hashMapNew();
    hashMapPut(map, "language", "Atlas");
    hashMapPut(map, "version", "0.2");
    hashMapPut(map, "year", "2026");

    let map_keys = hashMapKeys(map);
    let map_values = hashMapValues(map);
    let map_entries = hashMapEntries(map);

    // HashSet operations
    let set_a = hashSetFromArray([1, 2, 3]);
    let set_b = hashSetFromArray([3, 4, 5]);
    let union = hashSetUnion(set_a, set_b);
    let intersection = hashSetIntersection(set_a, set_b);
    let difference = hashSetDifference(set_a, set_b);

    // Queue
    let queue = queueNew();
    queueEnqueue(queue, "first");
    queueEnqueue(queue, "second");
    let queue_front_opt: Option<string> = queuePeek(queue);
    let queue_front = option_string(queue_front_opt);
    let dequeued_opt: Option<string> = queueDequeue(queue);
    let dequeued = option_string(dequeued_opt);
    let queue_after = queueToArray(queue);

    // Stack
    let stack = stackNew();
    stackPush(stack, "bottom");
    stackPush(stack, "top");
    let top_opt: Option<string> = stackPeek(stack);
    let top = option_string(top_opt);
    let popped_opt: Option<string> = stackPop(stack);
    let popped = option_string(popped_opt);
    let stack_after = stackToArray(stack);

    return "hashMap keys=" + toJSON(map_keys)
        + ", values=" + toJSON(map_values)
        + ", entries=" + toJSON(map_entries)
        + "; hashSet union=" + toJSON(hashSetToArray(union))
        + ", intersection=" + toJSON(hashSetToArray(intersection))
        + ", difference=" + toJSON(hashSetToArray(difference))
        + "; queue peek=" + queue_front + ", dequeued=" + dequeued
        + ", remainingQueue=" + toJSON(queue_after)
        + "; stack peek(before pop)=" + top + ", popped=" + popped
        + ", remainingStack=" + toJSON(stack_after);
}

fn option_string(opt: Option<string>) -> string {
    return match opt {
        Some(value) => value,
        None => "None",
        _ => "Unknown"
    };
}
