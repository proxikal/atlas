// Array operations and higher-order intrinsics

fn double(x: number) -> number {
    return x * 2;
}

fn is_even(x: number) -> bool {
    return x % 2 == 0;
}

fn sum(acc: number, value: number) -> number {
    return acc + value;
}

fn compare_desc(a: number, b: number) -> number {
    if (a > b) { return -1; }
    if (a < b) { return 1; }
    return 0;
}

fn explode(x: number) -> number[] {
    return [x, x * 10];
}

export fn demo_arrays() -> string {
    let numbers = [1, 2, 3, 4, 5];

    let doubled = map(numbers, double);
    let evens = filter(numbers, is_even);
    let total: number = reduce(numbers, sum, 0);
    let first_even_index: number = findIndex(numbers, is_even);
    let flattened = flatMap(numbers, explode);
    let any_gt3: bool = some(numbers, greater_than_three);
    let all_positive: bool = every(numbers, is_positive);
    let sorted_desc = sort(numbers, compare_desc);

    // slice uses start/end indices
    let middle = slice(numbers, 1, 4);

    return "numbers=" + toJSON(numbers)
        + ", doubled=" + toJSON(doubled)
        + ", evens=" + toJSON(evens)
        + ", total=" + str(total)
        + ", firstEvenIndex=" + str(first_even_index)
        + ", flatMap=" + toJSON(flattened)
        + ", any>3=" + str(any_gt3)
        + ", allPositive=" + str(all_positive)
        + ", sortedDesc=" + toJSON(sorted_desc)
        + ", slice(1,4)=" + toJSON(middle);
}

fn greater_than_three(n: number) -> bool {
    return n > 3;
}

fn is_positive(n: number) -> bool {
    return n > 0;
}
